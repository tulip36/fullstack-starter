#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createInterface } from 'readline';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.join(__dirname, '..');

const rl = createInterface({
  input: process.stdin,
  output: process.stdout,
});

// é¢œè‰²è¾“å‡º
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

function colorLog(color: keyof typeof colors, message: string) {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

// ç”Ÿæˆéšæœºå­—ç¬¦ä¸²
function generateRandomString(length: number): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

// è¯¢é—®ç”¨æˆ·è¾“å…¥
function question(query: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(`${colors.cyan}${query}${colors.reset}`, (answer) => {
      resolve(answer.trim());
    });
  });
}

// é€‰æ‹©é¢˜
function selectQuestion(query: string, options: string[]): Promise<string> {
  return new Promise((resolve) => {
    console.log(`${colors.bright}${query}${colors.reset}`);
    options.forEach((option, index) => {
      console.log(`${colors.cyan}${index + 1}.${colors.reset} ${option}`);
    });
    
    rl.question(`${colors.yellow}è¯·é€‰æ‹© (è¾“å…¥æ•°å­—):${colors.reset} `, (answer) => {
      const index = parseInt(answer, 10) - 1;
      if (index >= 0 && index < options.length) {
        resolve(options[index]);
      } else {
        colorLog('red', 'æ— æ•ˆé€‰æ‹©ï¼Œè¯·é‡æ–°é€‰æ‹©');
        resolve(selectQuestion(query, options));
      }
    });
  });
}

// ç¡®è®¤é—®é¢˜
function confirmQuestion(query: string): Promise<boolean> {
  return new Promise((resolve) => {
    rl.question(`${colors.yellow}${query} (y/N):${colors.reset} `, (answer) => {
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

// æ›´æ–°package.json
function updatePackageJson(key: string, value: any) {
  const packageJsonPath = path.join(projectRoot, 'package.json');
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
  
  if (key.includes('.')) {
    const keys = key.split('.');
    let current = packageJson;
    for (let i = 0; i < keys.length - 1; i++) {
      if (!current[keys[i]]) current[keys[i]] = {};
      current = current[keys[i]];
    }
    current[keys[keys.length - 1]] = value;
  } else {
    packageJson[key] = value;
  }
  
  fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
}

// åˆ›å»º.env.localæ–‡ä»¶
function createEnvFile(config: any) {
  const envContent = `# Environment Variables
# Generated by bootstrap script on ${new Date().toISOString()}

# Application
NODE_ENV=development
NEXT_PUBLIC_APP_NAME=${config.appName}
NEXT_PUBLIC_APP_DESCRIPTION=${config.appDescription}

# API Configuration
NEXT_PUBLIC_API_URL=http://localhost:${config.apiPort}
API_PORT=${config.apiPort}
WEB_PORT=${config.webPort}

# Database
DATABASE_URL="${config.databaseUrl}"

# Authentication
JWT_SECRET=${config.jwtSecret}
JWT_EXPIRES_IN=1h
REFRESH_TOKEN_EXPIRES_IN=7d

# Redis (Optional)
# REDIS_URL=redis://localhost:6379

# Email (Optional)
# SMTP_HOST=smtp.gmail.com
# SMTP_PORT=587
# SMTP_USER=your-email@gmail.com
# SMTP_PASS=your-app-password
# FROM_EMAIL=noreply@yourdomain.com

# File Upload
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=10485760
ALLOWED_FILE_TYPES=image/jpeg,image/png,image/gif,application/pdf

# Logging
LOG_LEVEL=info
LOG_FILE=./logs/app.log

# Development
NEXT_PUBLIC_DEV_MODE=true
`;

  fs.writeFileSync(path.join(projectRoot, '.env.local'), envContent);
}

// åˆ›å»ºå¿…è¦çš„ç›®å½•
function createDirectories() {
  const directories = [
    'logs',
    'uploads',
    'data',
  ];

  directories.forEach(dir => {
    const dirPath = path.join(projectRoot, dir);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
      colorLog('green', `âœ“ åˆ›å»ºç›®å½•: ${dir}`);
    }
  });
}

// ä¸»åˆå§‹åŒ–å‡½æ•°
async function bootstrap() {
  colorLog('cyan', 'ğŸš€ æ¬¢è¿ä½¿ç”¨ Monorepo Bootstrap åˆå§‹åŒ–å·¥å…·');
  colorLog('yellow', 'æœ¬å·¥å…·å°†å¸®åŠ©æ‚¨å¿«é€Ÿé…ç½®é¡¹ç›®ç¯å¢ƒ\n');

  try {
    // é¡¹ç›®åŸºæœ¬ä¿¡æ¯
    colorLog('bright', 'ğŸ“‹ é¡¹ç›®åŸºæœ¬ä¿¡æ¯');
    const appName = await question('é¡¹ç›®åç§°: ') || 'My Awesome App';
    const appDescription = await question('é¡¹ç›®æè¿°: ') || 'åŸºäºMonorepo Bootstrapçš„å…¨æ ˆåº”ç”¨';
    const author = await question('ä½œè€…åç§°: ') || '';

    // æ•°æ®åº“é…ç½®
    colorLog('\nğŸ“Š æ•°æ®åº“é…ç½®');
    const databaseType = await selectQuestion('é€‰æ‹©æ•°æ®åº“ç±»å‹:', [
      'SQLite (å¼€å‘ç¯å¢ƒæ¨è)',
      'PostgreSQL (ç”Ÿäº§ç¯å¢ƒæ¨è)',
      'MySQL',
    ]);

    let databaseUrl = '';
    switch (databaseType) {
      case 'SQLite (å¼€å‘ç¯å¢ƒæ¨è)':
        databaseUrl = 'file:./data/app.db';
        break;
      case 'PostgreSQL (ç”Ÿäº§ç¯å¢ƒæ¨è)':
        const pgHost = await question('PostgreSQLä¸»æœº (localhost): ') || 'localhost';
        const pgPort = await question('PostgreSQLç«¯å£ (5432): ') || '5432';
        const pgDb = await question('æ•°æ®åº“åç§°: ');
        const pgUser = await question('ç”¨æˆ·å: ');
        const pgPassword = await question('å¯†ç : ');
        databaseUrl = `postgresql://${pgUser}:${pgPassword}@${pgHost}:${pgPort}/${pgDb}`;
        break;
      case 'MySQL':
        const mysqlHost = await question('MySQLä¸»æœº (localhost): ') || 'localhost';
        const mysqlPort = await question('MySQLç«¯å£ (3306): ') || '3306';
        const mysqlDb = await question('æ•°æ®åº“åç§°: ');
        const mysqlUser = await question('ç”¨æˆ·å: ');
        const mysqlPassword = await question('å¯†ç : ');
        databaseUrl = `mysql://${mysqlUser}:${mysqlPassword}@${mysqlHost}:${mysqlPort}/${mysqlDb}`;
        break;
    }

    // ç«¯å£é…ç½®
    colorLog('\nğŸ”Œ ç«¯å£é…ç½®');
    const webPort = await question('å‰ç«¯ç«¯å£ (3000): ') || '3000';
    const apiPort = await question('åç«¯ç«¯å£ (3001): ') || '3001';

    // è®¤è¯é…ç½®
    colorLog('\nğŸ” è®¤è¯é…ç½®');
    const jwtSecret = generateRandomString(64);
    colorLog('green', `âœ“ JWTå¯†é’¥å·²ç”Ÿæˆ: ${jwtSecret.substring(0, 8)}...`);

    const enableEmailVerification = await confirmQuestion('å¯ç”¨é‚®ç®±éªŒè¯?');

    // é…ç½®æ±‡æ€»
    colorLog('\nğŸ“ é…ç½®æ±‡æ€»');
    console.log(`é¡¹ç›®åç§°: ${appName}`);
    console.log(`é¡¹ç›®æè¿°: ${appDescription}`);
    if (author) console.log(`ä½œè€…: ${author}`);
    console.log(`æ•°æ®åº“ç±»å‹: ${databaseType}`);
    console.log(`å‰ç«¯ç«¯å£: ${webPort}`);
    console.log(`åç«¯ç«¯å£: ${apiPort}`);
    console.log(`é‚®ç®±éªŒè¯: ${enableEmailVerification ? 'å¯ç”¨' : 'ç¦ç”¨'}`);

    // ç¡®è®¤é…ç½®
    const confirmed = await confirmQuestion('\nç¡®è®¤ä»¥ä¸Šé…ç½®å¹¶ç»§ç»­?');
    if (!confirmed) {
      colorLog('yellow', 'åˆå§‹åŒ–å·²å–æ¶ˆ');
      rl.close();
      return;
    }

    // å¼€å§‹é…ç½®
    colorLog('\nâš™ï¸ å¼€å§‹é…ç½®é¡¹ç›®...');

    // æ›´æ–°package.json
    updatePackageJson('name', appName.toLowerCase().replace(/\s+/g, '-'));
    updatePackageJson('description', appDescription);
    if (author) updatePackageJson('author', author);

    // åˆ›å»º.env.localæ–‡ä»¶
    const config = {
      appName,
      appDescription,
      webPort,
      apiPort,
      databaseUrl,
      jwtSecret,
    };
    createEnvFile(config);
    colorLog('green', 'âœ“ åˆ›å»º .env.local æ–‡ä»¶');

    // åˆ›å»ºå¿…è¦ç›®å½•
    createDirectories();

    // å®‰è£…ä¾èµ–
    colorLog('\nğŸ“¦ å®‰è£…ä¾èµ–åŒ…...');
    const { spawn } = await import('child_process');
    
    await new Promise<void>((resolve, reject) => {
      const pnpm = spawn('pnpm', ['install'], {
        stdio: 'inherit',
        cwd: projectRoot,
      });
      
      pnpm.on('close', (code) => {
        if (code === 0) {
          colorLog('green', 'âœ“ ä¾èµ–å®‰è£…å®Œæˆ');
          resolve();
        } else {
          colorLog('red', 'âœ— ä¾èµ–å®‰è£…å¤±è´¥');
          reject(new Error('ä¾èµ–å®‰è£…å¤±è´¥'));
        }
      });
    });

    // ç”ŸæˆPrismaå®¢æˆ·ç«¯
    colorLog('\nğŸ—„ï¸ ç”Ÿæˆæ•°æ®åº“å®¢æˆ·ç«¯...');
    await new Promise<void>((resolve, reject) => {
      const prisma = spawn('pnpm', ['--filter', 'database', 'db:generate'], {
        stdio: 'inherit',
        cwd: projectRoot,
      });
      
      prisma.on('close', (code) => {
        if (code === 0) {
          colorLog('green', 'âœ“ Prismaå®¢æˆ·ç«¯ç”Ÿæˆå®Œæˆ');
          resolve();
        } else {
          colorLog('red', 'âœ— Prismaå®¢æˆ·ç«¯ç”Ÿæˆå¤±è´¥');
          reject(new Error('Prismaå®¢æˆ·ç«¯ç”Ÿæˆå¤±è´¥'));
        }
      });
    });

    // è¿è¡Œæ•°æ®åº“è¿ç§»
    colorLog('\nğŸ”„ è¿è¡Œæ•°æ®åº“è¿ç§»...');
    await new Promise<void>((resolve, reject) => {
      const migrate = spawn('pnpm', ['--filter', 'database', 'db:migrate'], {
        stdio: 'inherit',
        cwd: projectRoot,
      });
      
      migrate.on('close', (code) => {
        if (code === 0) {
          colorLog('green', 'âœ“ æ•°æ®åº“è¿ç§»å®Œæˆ');
          resolve();
        } else {
          colorLog('red', 'âœ— æ•°æ®åº“è¿ç§»å¤±è´¥');
          reject(new Error('æ•°æ®åº“è¿ç§»å¤±è´¥'));
        }
      });
    });

    // è¿è¡Œç§å­æ•°æ®
    colorLog('\nğŸŒ± åˆå§‹åŒ–ç§å­æ•°æ®...');
    await new Promise<void>((resolve, reject) => {
      const seed = spawn('pnpm', ['--filter', 'database', 'db:seed'], {
        stdio: 'inherit',
        cwd: projectRoot,
      });
      
      seed.on('close', (code) => {
        if (code === 0) {
          colorLog('green', 'âœ“ ç§å­æ•°æ®åˆå§‹åŒ–å®Œæˆ');
          resolve();
        } else {
          colorLog('yellow', 'âš  ç§å­æ•°æ®åˆå§‹åŒ–å¤±è´¥ï¼Œä½†ä¸å½±å“æ­£å¸¸ä½¿ç”¨');
          resolve();
        }
      });
    });

    // å®Œæˆ
    colorLog('\nğŸ‰ é¡¹ç›®åˆå§‹åŒ–å®Œæˆï¼');
    colorLog('green', '\nğŸš€ å¯åŠ¨å¼€å‘æœåŠ¡å™¨:');
    console.log('  pnpm dev          # åŒæ—¶å¯åŠ¨å‰åç«¯');
    console.log('  pnpm dev:web      # ä»…å¯åŠ¨å‰ç«¯');
    console.log('  pnpm dev:api      # ä»…å¯åŠ¨åç«¯');
    console.log('  pnpm db:studio    # æ‰“å¼€æ•°æ®åº“ç®¡ç†ç•Œé¢');
    
    colorLog('\nğŸ“š å…¶ä»–å‘½ä»¤:');
    console.log('  pnpm build        # æ„å»ºé¡¹ç›®');
    console.log('  pnpm test         # è¿è¡Œæµ‹è¯•');
    console.log('  pnpm lint         # ä»£ç æ£€æŸ¥');
    console.log('  pnpm format       # ä»£ç æ ¼å¼åŒ–');

    colorLog('\nğŸŒ è®¿é—®åœ°å€:');
    console.log(`  å‰ç«¯: http://localhost:${webPort}`);
    console.log(`  åç«¯: http://localhost:${apiPort}`);
    console.log(`  APIæ–‡æ¡£: http://localhost:${apiPort}/docs`);

    colorLog('\nğŸ“– æµ‹è¯•è´¦å·:');
    console.log('  é‚®ç®±: test@example.com');
    console.log('  å¯†ç : Password123');

  } catch (error) {
    colorLog('red', `\nâŒ åˆå§‹åŒ–å¤±è´¥: ${error}`);
    process.exit(1);
  } finally {
    rl.close();
  }
}

// è¿è¡Œåˆå§‹åŒ–
bootstrap();